<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARCHIMAP</title>
  <link href="https://fonts.googleapis.com/css2?family=Signika:wght@400;600&display=swap" rel="stylesheet">
<style>
@import url('https://fonts.googleapis.com/css2?family=Signika:wght@400;600&display=swap');
    
body {
  font-family: 'Banschrift', 'Signika', sans-serif;
  background-color: #121212;
  color: #cccccc;
  margin: 0;
  padding: 0;
}

    

header {
  background-color: #1e1e1e;
  padding: 1rem;
  border-bottom: 1px solid #333;
  display: flex;
  justify-content: space-between;
  align-items: center;
}


    

h1 {
  margin: 0;
  font-size: 1.5rem;
  font-family: Helvetica, sans-serif;
}


    
#controls {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.75rem;
  padding: 1rem;
  background-color: #181818;
  border-bottom: 1px solid #333;
}

    #controls label {
      margin-right: 0.5rem;
      font-weight: bold;
    }
    
#controls input {
  background-color: #2a2a2a;
  color: #ccc;
  border: 1px solid #444;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  margin-right: 0;
}

    #map {
      height: calc(100vh - 120px);
      width: 100%;
    }
    .info-window {
      max-width: 250px;
    }

    /* Styling for the toggle button that shows/hides the search and filter controls
       on small screens. Hidden by default in the markup, but becomes visible
       via media queries below. */
    #toggle-controls {
      background-color: #333;
      color: #ccc;
      border: 1px solid #555;
      padding: 4px 8px;
      margin: 0.5rem;
      border-radius: 4px;
      cursor: pointer;
    }

    /* On screens narrower than 600px, hide the controls panel and show the
       toggle button. On wider screens, show the controls and hide the toggle. */
    @media (max-width: 600px) {
      #controls {
        display: none;
      }
      #toggle-controls {
        display: inline-block;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>ARCHIMAP</h1>
    <!-- Update the tagline text and decrease its font size as requested -->
    <span style="font-size: 0.85rem; color: #aaa; margin: 0;">Find Architecture</span>
  </header>
  <!-- Toggle button to show/hide the search and filter controls on small screens -->
  <!-- The Filters button toggles the visibility of the controls. It is
       visible on all screen sizes so users can always collapse or
       expand the search panel. -->
  <!-- Toggle button with no label; its icon will be set via JavaScript -->
  <button id="toggle-controls"></button>
  <div id="controls">
    <label for="radius">Radius (km):</label>
    <input type="number" id="radius" autocomplete="off" value="5" min="1" step="1" style="width:60px">
    <label for="date_from">From year:</label>
    <input type="number" id="date_from" autocomplete="off" placeholder="1900" style="width:80px">
    <label for="date_to">To year:</label>
    <input type="number" id="date_to" autocomplete="off" placeholder="2025" style="width:80px">
    <label for="keyword">Keyword:</label>
    <input type="text" id="keyword" autocomplete="off" placeholder="Architect, style…" style="width:120px">
    <button style="background:#333;color:#ccc;border:1px solid #555;padding:4px 8px;" onclick="search()">Search</button>
    
    <label for="address" style="margin-top:0.5rem">Search near address:</label>
    <input type="text" id="address" autocomplete="off" placeholder="Enter city or address" style="width:200px">
    <button style="background:#333;color:#ccc;border:1px solid #555;padding:4px 8px;" onclick="geocodeAddress()">Go</button>
  </div>
  <div id="map"></div>

  <!--
    The following script and container embed a Google Custom Search Engine (CSE)
    search box on the page. This search box queries your custom engine defined
    by the cx value above (76d6c678a45b64fda). Results returned by this search
    box appear inline beneath the input field. It works independently from the
    map integration implemented in the JavaScript above but provides a
    convenient fallback UI for users who wish to perform a site‑restricted
    search without relying on the map interface.
  -->
  <script async src="https://cse.google.com/cse.js?cx=76d6c678a45b64fda"></script>
  <div class="gcse-search"></div>
  <script>
    // Google Maps API key used for both map and geocoding. Update this
    // variable if you change the key in the script tag below.
    const apiKey = 'AIzaSyDDLRyAF2vvdjYZuPCD2jko4M9tY125wjg';
    // Global variables for map, the draggable "you" marker, user location
    // and markers. `youMarker` represents the green arrow used to set
    // the current search center and is reused when the center changes.
    let map;
    let youMarker;
    let userLat = null;
    let userLng = null;
    let markers = [];

    /**
     * -------------------------------------------------------------------------
     *  Google Programmable Search Engine (PSE) Integration
     *
     *  This application can optionally query a Google Programmable Search
     *  Engine (also known as Custom Search Engine) to fetch architecture
     *  articles from third‑party sites like Archdaily, Dezeen and Archinect.
     *
     *  To enable PSE searching you must set up your own search engine at
     *  https://programmablesearchengine.google.com/about/ and restrict it to
     *  the desired sites. Then populate the two constants below with your
     *  Google API key and the custom search engine ID (cx). Leaving these
     *  values blank will disable PSE integration and fall back to the
     *  Wikipedia geosearch logic implemented later in this file.
     */
    // API key used for PSE requests. This key is the same as your Google Maps
    // key; Google allows using a single key for multiple services. Replace
    // this string with your real API key if different.
    const pseApiKey = 'AIzaSyDDLRyAF2vvdjYZuPCD2jko4M9tY125wjg';
    // Custom search engine ID generated when you created your PSE. Replace
    // this with your own CX identifier.
    const pseCx = '76d6c678a45b64fda';

    /**
     * Perform a search against a Google Programmable Search Engine and plot the
     * resulting articles on the map. Each result is geocoded using the
     * article title; duplicate titles are ignored. Markers created by this
     * function are stored in the global `markers` array for later cleanup.
     *
     * @param {string} query The search query to pass to the custom search API.
     */
    async function searchWithPSE(query) {
      // If no API key or cx is configured, do nothing.
      if (!pseApiKey || !pseCx) {
        console.warn('PSE API key or search engine ID not provided; skipping PSE search');
        return;
      }
      // Clear any existing markers before plotting new ones.
      clearMarkers();
      const apiURL = `https://www.googleapis.com/customsearch/v1?key=${pseApiKey}&cx=${pseCx}&q=${encodeURIComponent(query)}`;
      try {
        const resp = await fetch(apiURL);
        if (!resp.ok) {
          throw new Error(`PSE request failed with status ${resp.status}`);
        }
        const data = await resp.json();
        const items = data.items || [];
        if (items.length === 0) {
          alert('No PSE results found for your query.');
          return;
        }
        const seen = new Set();
        for (const item of items) {
          // Normalise title and skip if we have already plotted it
          const title = item.title || '';
          const fingerprint = title.trim().toLowerCase();
          if (seen.has(fingerprint) || !fingerprint) {
            continue;
          }
          seen.add(fingerprint);
          const snippet = item.snippet || '';
          const link = item.link || '';
          // Derive the domain from the link if available; fallback to displayLink
          let site = '';
          try {
            if (link) {
              const urlObj = new URL(link);
              site = urlObj.hostname;
            } else if (item.displayLink) {
              site = item.displayLink;
            }
          } catch (err) {
            site = item.displayLink || '';
          }
          // Geocode the article title. Using the Maps API key defined globally.
          const geocodeUrl = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(title)}&key=${apiKey}`;
          try {
            const gResp = await fetch(geocodeUrl);
            if (!gResp.ok) {
              console.warn('Geocode request failed for', title);
              continue;
            }
            const gData = await gResp.json();
            if (gData.status !== 'OK' || !gData.results || gData.results.length === 0) {
              console.warn('No geocode results for', title);
              continue;
            }
            const location = gData.results[0].geometry.location;
            const marker = new google.maps.Marker({
              position: { lat: location.lat, lng: location.lng },
              map: map,
              title: title
            });
            markers.push(marker);
            // Build info window content for this marker
            let content = `<div class="info-window"><h3>${title}</h3>`;
            if (site) {
              content += `<p><strong>Site:</strong> ${site}</p>`;
            }
            if (snippet) {
              content += `<p>${snippet}</p>`;
            }
            if (link) {
              content += `<p><a href="${link}" target="_blank" rel="noopener">Read article</a></p>`;
            }
            content += '</div>';
            const infoWindow = new google.maps.InfoWindow({ content: content });
            marker.addListener('click', () => {
              infoWindow.open(map, marker);
            });
          } catch (geErr) {
            console.warn('Geocoding error for', title, geErr);
          }
        }
      } catch (err) {
        console.error('PSE search error:', err);
        alert('An error occurred while fetching data from the custom search API.');
      }
    }

    /**
     * Reverse geocode a latitude/longitude to obtain the city and country names.
     * Uses the Google Maps Geocoding API. Returns an object with `city` and
     * `country` properties; if no city or country is found the value will be
     * `null`. A missing API key or request error results in both values being
     * `null`.
     *
     * @param {number} lat Latitude to reverse geocode
     * @param {number} lng Longitude to reverse geocode
     * @returns {Promise<{city: string|null, country: string|null}>}
     */
    async function getCityAndCountry(lat, lng) {
      const result = { city: null, country: null };
      try {
        const url = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${apiKey}`;
        const resp = await fetch(url);
        if (!resp.ok) {
          console.warn('Reverse geocode request failed with status', resp.status);
          return result;
        }
        const data = await resp.json();
        if (!data.results || data.results.length === 0) {
          console.warn('No reverse geocode results for location');
          return result;
        }
        // Inspect address components of the first result
        const components = data.results[0].address_components || [];
        for (const comp of components) {
          if (comp.types.includes('locality')) {
            result.city = comp.long_name;
          }
          if (comp.types.includes('country')) {
            result.country = comp.long_name;
          }
        }
      } catch (err) {
        console.error('Reverse geocode error:', err);
      }
      return result;
    }

    /**
     * Query the Programmable Search Engine and return the raw result items.
     * This helper does not create markers or modify the map. It simply
     * performs the fetch and returns the `items` array from the API response.
     * Any errors are swallowed and result in an empty array.
     *
     * @param {string} query The search string to send to the PSE
     * @returns {Promise<Array>} List of search result objects
     */
    async function getPseResults(query) {
      if (!pseApiKey || !pseCx) {
        return [];
      }
      // The Custom Search API returns only up to 10 results per request. To
      // retrieve more results, we paginate using the `start` parameter. This
      // implementation fetches up to 30 results (three pages) or stops early
      // if fewer items are returned. Adjust `maxPages` as needed, being
      // mindful of API quotas.
      // The API supports up to 10 pages of 10 results each (100 total).
      // Adjust maxPages to 10 to maximise the number of results returned.
      const maxPages = 10;
      const allItems = [];
      for (let page = 0; page < maxPages; page++) {
        const startIndex = 1 + page * 10;
        const apiURL = `https://www.googleapis.com/customsearch/v1?key=${pseApiKey}&cx=${pseCx}&q=${encodeURIComponent(query)}&start=${startIndex}`;
        try {
          const resp = await fetch(apiURL);
          if (!resp.ok) {
            console.warn('PSE request failed with status', resp.status, 'for page', page + 1);
            break;
          }
          const data = await resp.json();
          const items = data.items || [];
          allItems.push(...items);
          // If fewer than 10 items were returned, no more pages are available
          if (items.length < 10) {
            break;
          }
        } catch (err) {
          console.error('PSE fetch error on page', page + 1, ':', err);
          break;
        }
      }
      return allItems;
    }

    /**
     * Compute the great‑circle distance between two coordinates using the
     * Haversine formula. Returns the distance in kilometres.
     *
     * @param {number} lat1 Latitude of first point
     * @param {number} lng1 Longitude of first point
     * @param {number} lat2 Latitude of second point
     * @param {number} lng2 Longitude of second point
     * @returns {number} Distance in kilometres
     */
    function haversine(lat1, lng1, lat2, lng2) {
      const toRad = deg => deg * Math.PI / 180;
      const R = 6371; // Earth radius in km
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    /**
     * Initialize the Google Map. This function attempts to determine the
     * user's geolocation. If geolocation is unavailable or denied, the
     * map centers on Vancouver, Canada by default. A marker marks the
     * user's (or default) position.
     */
    function initMap() {
      function createMap(lat, lng) {
  console.log('Creating map at:', lat, lng);
        userLat = lat;
        userLng = lng;
        map = new google.maps.Map(document.getElementById('map'), {
          styles: [{"elementType": "geometry", "stylers": [{"color": "#212121"}]}, {"elementType": "labels.icon", "stylers": [{"visibility": "off"}]}, {"elementType": "labels.text.fill", "stylers": [{"color": "#757575"}]}, {"elementType": "labels.text.stroke", "stylers": [{"color": "#212121"}]}, {"featureType": "administrative", "elementType": "geometry", "stylers": [{"color": "#757575"}]}, {"featureType": "administrative.country", "elementType": "labels.text.fill", "stylers": [{"color": "#9e9e9e"}]}, {"featureType": "administrative.land_parcel", "stylers": [{"visibility": "off"}]}, {"featureType": "administrative.locality", "elementType": "labels.text.fill", "stylers": [{"color": "#bdbdbd"}]}, {"featureType": "poi", "elementType": "labels.text.fill", "stylers": [{"color": "#757575"}]}, {"featureType": "poi.park", "elementType": "geometry", "stylers": [{"color": "#181818"}]}, {"featureType": "poi.park", "elementType": "labels.text.fill", "stylers": [{"color": "#616161"}]}, {"featureType": "poi.park", "elementType": "labels.text.stroke", "stylers": [{"color": "#1b1b1b"}]}, {"featureType": "road", "elementType": "geometry.fill", "stylers": [{"color": "#2c2c2c"}]}, {"featureType": "road", "elementType": "labels.text.fill", "stylers": [{"color": "#8a8a8a"}]}, {"featureType": "road.arterial", "elementType": "geometry", "stylers": [{"color": "#373737"}]}, {"featureType": "road.highway", "elementType": "geometry", "stylers": [{"color": "#3c3c3c"}]}, {"featureType": "road.highway.controlled_access", "elementType": "geometry", "stylers": [{"color": "#4e4e4e"}]}, {"featureType": "road.local", "elementType": "labels.text.fill", "stylers": [{"color": "#616161"}]}, {"featureType": "transit", "elementType": "labels.text.fill", "stylers": [{"color": "#757575"}]}, {"featureType": "water", "elementType": "geometry", "stylers": [{"color": "#000000"}]}, {"featureType": "water", "elementType": "labels.text.fill", "stylers": [{"color": "#3d3d3d"}]}],
          center: { lat: userLat, lng: userLng },
          zoom: 13,
          mapTypeControl: true,
          mapTypeControlOptions: {
            style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
          }
        });
        // Create the draggable green arrow marker used to indicate the current
        // search center. Assign it to the global `youMarker` so it can be
        // repositioned later when the user enters a new address.
        youMarker = new google.maps.Marker({
      position: { lat: userLat, lng: userLng },
      map: map,
      draggable: true,
      title: 'Drag to change search center',
      icon: {
        path: google.maps.SymbolPath.BACKWARD_CLOSED_ARROW,
        scale: 5,
        fillColor: '#228B22',
        fillOpacity: 1,
        strokeWeight: 1,
        strokeColor: '#1a641a'
      }
    });
        youMarker.addListener('dragend', (e) => {
          userLat = e.latLng.lat();
          userLng = e.latLng.lng();
          map.setCenter({ lat: userLat, lng: userLng });
          search();
        });
      }
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition((position) => {
        console.log('Using geolocation');
            console.log("Geolocation success", position.coords.latitude, position.coords.longitude);
            createMap(position.coords.latitude, position.coords.longitude);
          },
          () => {
            // If permission denied or unavailable, use Vancouver as default
            console.warn("Geolocation failed or denied. Using Vancouver as fallback.");
            createMap(49.2827, -123.1207);
          }
        );
      } else {
        console.warn("Geolocation failed or denied. Using Vancouver as fallback.");
            createMap(49.2827, -123.1207);
      }
    }

    /**
     * Remove all markers from the map and clear the markers array.
     */
    function clearMarkers() {
      for (const m of markers) {
        m.setMap(null);
      }
      markers = [];
    }

    /**
     * Geocode an arbitrary address using the Google Geocoding API. When a
     * user enters an address and clicks "Go", this function queries
     * Google's geocoder with the provided text. On success, the map
     * recenters on the resulting coordinates and a search is performed to
     * update the architectural results. If no results are found or an
     * error occurs, an alert is shown to the user.
     */
    async function geocodeAddress() {
      const address = document.getElementById('address').value.trim();
      if (!address) {
        alert('Please enter an address or location.');
        return;
      }
      const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`;
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Geocoding request failed');
        }
        const data = await response.json();
        if (data.status !== 'OK' || !data.results || data.results.length === 0) {
          alert('No results found for the provided address.');
          return;
        }
        const result = data.results[0];
        const location = result.geometry.location;
        userLat = location.lat;
        userLng = location.lng;
        // Recenter map to new location
        map.setCenter({ lat: userLat, lng: userLng });
        // Reposition the existing green arrow marker to the new location.
        // If it doesn't exist yet (e.g., map still loading), create it.
        if (youMarker) {
          youMarker.setPosition({ lat: userLat, lng: userLng });
        } else {
          youMarker = new google.maps.Marker({
            position: { lat: userLat, lng: userLng },
            map: map,
            draggable: true,
            title: 'Drag to change search center',
            icon: {
              path: google.maps.SymbolPath.BACKWARD_CLOSED_ARROW,
              scale: 5,
              fillColor: '#228B22',
              fillOpacity: 1,
              strokeWeight: 1,
              strokeColor: '#1a641a'
            }
          });
          youMarker.addListener('dragend', (e) => {
            userLat = e.latLng.lat();
            userLng = e.latLng.lng();
            map.setCenter({ lat: userLat, lng: userLng });
            search();
          });
        }
        // Perform a search with the new coordinates
        search();
      } catch (error) {
        console.error('Geocoding error:', error);
        alert('An error occurred while geocoding the address.');
      }
    }

    // Allow pressing Enter in the address input to trigger geocoding instead of
    // requiring a click on the Go button. This improves usability on both
    // desktop and mobile devices.
    const addressInput = document.getElementById('address');
    if (addressInput) {
      addressInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          geocodeAddress();
        }
      });
    }

    // Toggle the visibility of the search/filter controls when the
    // Filters button is tapped. This reduces screen real estate usage
    // on small displays.
    const toggleBtn = document.getElementById('toggle-controls');
    const controlsDiv = document.getElementById('controls');
    if (toggleBtn && controlsDiv) {
      // Function to update the arrow icon based on the visibility of the controls
      const updateToggleIcon = () => {
        const currentDisplay = window.getComputedStyle(controlsDiv).display;
        // Down arrow when panel is hidden, up arrow when visible
        toggleBtn.textContent = currentDisplay === 'none' ? '▼' : '▲';
      };
      // Initialize the icon based on the initial state (e.g. hidden on small screens)
      updateToggleIcon();
      toggleBtn.addEventListener('click', () => {
        const currentDisplay = window.getComputedStyle(controlsDiv).display;
        if (currentDisplay === 'none') {
          // When showing, use flex layout to match original styling
          controlsDiv.style.display = 'flex';
        } else {
          controlsDiv.style.display = 'none';
        }
        // Update the icon after toggling
        updateToggleIcon();
      });
      // Also update the icon on window resize to adapt to CSS media query changes
      window.addEventListener('resize', updateToggleIcon);
    }

    /**
     * Perform a geosearch via the Wikipedia API. It requests pages
     * located within a specified radius of the user's location. The
     * function then retrieves additional metadata (summary and
     * inception year) and filters the results according to user
     * criteria.
     */
    async function search() {
      if (userLat === null || userLng === null) {
        alert('Map not yet initialized. Please wait.');
        return;
      }
      // Fetch the search radius from the input and default to 5 km if invalid.
      const radiusKm = parseFloat(document.getElementById('radius').value);
      const radius = isNaN(radiusKm) ? 5 : radiusKm;
      // Clear any existing markers before adding new ones.
      clearMarkers();
      // Determine the city and country corresponding to the current marker location.
      const place = await getCityAndCountry(userLat, userLng);
      let city = place.city;
      let country = place.country;
      // Pull results from the PSE based on city or country. Try city first; if
      // none are found fall back to country. If both are null or no results
      // are returned, alert the user.
      let items = [];
      if (city) {
        items = await getPseResults(city);
      }
      if ((!items || items.length === 0) && country) {
        items = await getPseResults(country);
      }
      if (!items || items.length === 0) {
        alert('No results found for your location.');
        return;
      }
      const seen = new Set();
      let addedCount = 0;
      for (const item of items) {
        const title = item.title || '';
        const fingerprint = title.trim().toLowerCase();
        if (!fingerprint || seen.has(fingerprint)) {
          continue;
        }
        seen.add(fingerprint);
        const snippet = item.snippet || '';
        const link = item.link || '';
        let site = '';
        try {
          if (link) {
            const urlObj = new URL(link);
            site = urlObj.hostname;
          } else if (item.displayLink) {
            site = item.displayLink;
          }
        } catch (err) {
          site = item.displayLink || '';
        }
        // Try multiple geocoding queries (city, country, then title alone) to improve matches.
        const geocodeQueries = [];
        if (city) {
          geocodeQueries.push(`${title} ${city}`);
        }
        if (country && country !== city) {
          geocodeQueries.push(`${title} ${country}`);
        }
        geocodeQueries.push(title);
        let foundLocation = null;
        for (const queryStr of geocodeQueries) {
          const geocodeUrl = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(queryStr)}&key=${apiKey}`;
          try {
            const gResp = await fetch(geocodeUrl);
            if (!gResp.ok) {
              console.warn('Geocode request failed for', title, 'with query', queryStr);
              continue;
            }
            const gData = await gResp.json();
            if (gData.status === 'OK' && gData.results && gData.results.length > 0) {
              foundLocation = gData.results[0].geometry.location;
              break;
            }
          } catch (err) {
            console.warn('Geocode error for', title, 'with query', queryStr, ':', err);
          }
        }
        if (!foundLocation) {
          continue;
        }
        // Filter out results that fall outside the radius
        const distance = haversine(userLat, userLng, foundLocation.lat, foundLocation.lng);
        if (distance > radius) {
          continue;
        }
        // Create marker and info window for valid result
        const marker = new google.maps.Marker({
          position: { lat: foundLocation.lat, lng: foundLocation.lng },
          map: map,
          title: title
        });
        markers.push(marker);
        addedCount++;
        let content = `<div class="info-window"><h3>${title}</h3>`;
        if (site) {
          content += `<p><strong>Site:</strong> ${site}</p>`;
        }
        if (snippet) {
          content += `<p>${snippet}</p>`;
        }
        if (link) {
          content += `<p><a href="${link}" target="_blank" rel="noopener">Read article</a></p>`;
        }
        content += '</div>';
        const infoWindow = new google.maps.InfoWindow({ content: content });
        marker.addListener('click', () => {
          infoWindow.open(map, marker);
        });
      }
      if (addedCount === 0) {
        alert('No results found within the specified radius.');
      }
      return;
    }
  </script>
  <!--
    Insert your Google Maps API key below. Replace YOUR_API_KEY with your own key.
    See https://developers.google.com/maps/documentation/javascript/get-api-key
    for instructions on obtaining a key.
  -->
  <!-- Google Maps API key inserted as requested -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDDLRyAF2vvdjYZuPCD2jko4M9tY125wjg&callback=initMap" async defer></script>
</body>
</html>